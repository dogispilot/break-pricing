<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Skunksniper.com</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: #f9f9f9;
      color: #333;
    }
    header {
      display: flex;
      align-items: center;
      margin-bottom: 20px;
    }
    header img {
      width: 50px;
      height: 50px;
      margin-right: 10px;
    }
    header h1 {
      margin: 0;
      font-size: 2em;
    }
    header p {
      font-style: italic;
      margin: 0 0 0 60px;
      color: #666;
    }
    section {
      background: #fff;
      padding: 15px;
      margin-bottom: 20px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .tile-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 10px;
    }
    .tile {
      flex: 1 1 150px;
      background: #eaeaea;
      padding: 10px;
      border-radius: 4px;
      text-align: center;
    }
    .hero {
      font-weight: bold;
      background: #d0d0d0;
    }
    #set-selection select {
      padding: 5px;
      margin: 0 5px;
    }
    #set-notes {
      display: none;
      padding: 10px;
      border: 1px dashed #aaa;
      margin-top: 5px;
    }
    #break-sniffer input[type="number"] {
      width: 100px;
      padding: 5px;
      margin-right: 10px;
    }
    #break-sniffer label {
      margin-right: 10px;
    }
    #pieChart {
      width: 200px;
      height: 200px;
      margin-right: 20px;
    }
    #break-results {
      display: flex;
      align-items: center;
      margin-bottom: 20px;
    }
    #break-results .tiles {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
    }
    table, th, td {
      border: 1px solid #ccc;
    }
    th, td {
      padding: 8px;
      text-align: center;
    }
    .toggle-switch {
      display: inline-block;
      position: relative;
      width: 50px;
      height: 24px;
      margin-left: 5px;
      vertical-align: middle;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 24px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: #66bb6a;
    }
    input:checked + .slider:before {
      transform: translateX(26px);
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header>
    <img src="resources/skunk.png" alt="Skunk logo">
    <h1>Skunksniper.com</h1>
  </header>
  <p>Sniff out the best breaks</p>

  <!-- Section 1: Set and Year Selection -->
  <section id="set-selection">
    <p>
      I want to explore 
      <select id="setNameSelect">
        <option value="">-- Select Set Name --</option>
      </select>
      for the years 
      <select id="setYearSelect">
        <!-- Default should be 2024-25 if available -->
      </select>
    </p>
  </section>

  <!-- Section 2: Set Details -->
  <section id="set-details">
    <div id="details-text"></div>
    <a href="#" id="toggleNotes" style="text-decoration:underline;">Read Set Notes</a>
    <div id="set-notes"></div>
    <div class="tile-container" id="set-tiles">
      <!-- Tiles will be added here -->
    </div>
  </section>

  <!-- Section 3: Key Rookies -->
  <section id="key-rookies">
    <h2>Key Rookies</h2>
    <div class="tile-container" id="rookie-tiles">
      <!-- Key rookie tiles will be added here -->
    </div>
  </section>

  <!-- Section 4: Break Sniffer -->
  <section id="break-sniffer">
    <h2>Break Sniffer</h2>
    <div id="break-inputs">
      <label>
        Cost of a case:
        <input type="number" id="caseCost" step="0.01" value="1999.95">
      </label>
      <label>
        Markup:
        <input type="number" id="markupValue" step="0.01" value="0">
      </label>
      <label>
        <input type="checkbox" id="markupToggle">
        <span>Use % markup</span>
      </label>
      <label>
        Cost of supplies per team:
        <input type="number" id="suppliesCost" step="0.01" value="1.00">
      </label>
      <label>
        Blended tax (%):
        <input type="number" id="blendedTax" step="0.1" value="5.1">
      </label>
      <button id="calcBreak">Calculate</button>
    </div>
    <div id="break-results">
      <canvas id="pieChart" width="200" height="200"></canvas>
      <div class="tiles" id="break-tiles">
        <!-- Tiles for Breaker's Profit, Whatnots Cut, Cost of Business -->
      </div>
    </div>
    <!-- Table of team breakdown -->
    <table id="team-table">
      <thead>
        <tr>
          <th>Team</th>
          <th>Total Numbered Cards</th>
          <th>Distribution (%)</th>
          <th>Avg. Cards per Case</th>
          <th>Distributed Cost + Markup</th>
        </tr>
      </thead>
      <tbody>
        <!-- Rows will be added here -->
      </tbody>
    </table>
  </section>

  <script>
    // Global config variable
    let config = null;
    let currentSet = null; // the set currently selected (matching both name and year)

    // Fetch config.json on load
    async function loadConfig() {
      try {
        const response = await fetch('config.json');
        config = await response.json();
        populateDropdowns();
      } catch (error) {
        console.error("Error loading config.json:", error);
      }
    }

    // Populate the dropdowns for set names and years
    function populateDropdowns() {
      const setNameSelect = document.getElementById('setNameSelect');
      const setYearSelect = document.getElementById('setYearSelect');
      let years = new Set();
      let names = new Set();
      // Gather unique years and names from config.sets
      config.sets.forEach(s => {
        years.add(s.year);
        names.add(s.name);
      });

      // Convert sets to arrays and sort (if desired)
      years = Array.from(years).sort();
      names = Array.from(names).sort();

      // Add default option for year; ensure default is "2024-25" if not in list
      const defaultYear = "2024-25";
      if (!years.includes(defaultYear)) {
        years.unshift(defaultYear);
      }
      years.forEach(year => {
        const opt = document.createElement('option');
        opt.value = year;
        opt.textContent = year;
        if (year === defaultYear) opt.selected = true;
        setYearSelect.appendChild(opt);
      });

      names.forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        setNameSelect.appendChild(opt);
      });
    }

    // Event listeners for dropdowns and button
    document.getElementById('setNameSelect').addEventListener('change', onSelectionChange);
    document.getElementById('setYearSelect').addEventListener('change', onSelectionChange);
    document.getElementById('calcBreak').addEventListener('click', updateBreakSniffer);
    document.getElementById('toggleNotes').addEventListener('click', function(e){
      e.preventDefault();
      const notesDiv = document.getElementById('set-notes');
      notesDiv.style.display = (notesDiv.style.display === 'none' || notesDiv.style.display === '') ? 'block' : 'none';
    });

    // When set name or year is changed, update details
    function onSelectionChange() {
      const setName = document.getElementById('setNameSelect').value;
      const setYear = document.getElementById('setYearSelect').value;
      // Find the matching set
      currentSet = config.sets.find(s => s.name === setName && s.year === setYear);
      updateSetDetails();
      updateBreakCaseCost();
      updateKeyRookies();
      // Optionally clear break sniffer and table if no set is selected
      if (!currentSet) {
        document.getElementById('details-text').textContent = '';
        document.getElementById('set-tiles').innerHTML = '';
        document.getElementById('team-table').querySelector('tbody').innerHTML = '';
      }
    }

    // Update the cost input field in break sniffer if set price is available
    function updateBreakCaseCost() {
      if (currentSet && currentSet.price) {
        // Remove any non-numeric characters and convert to number
        const priceNum = parseFloat(currentSet.price.replace(/[^0-9.]/g, ''));
        if (!isNaN(priceNum)) {
          document.getElementById('caseCost').value = priceNum.toFixed(2);
        }
      }
    }

    // Update the Set Details section based on currentSet
    function updateSetDetails() {
      const detailsDiv = document.getElementById('details-text');
      const notesDiv = document.getElementById('set-notes');
      const tilesDiv = document.getElementById('set-tiles');
      if (!currentSet) {
        detailsDiv.textContent = "No set found for the selected name and year.";
        notesDiv.textContent = "";
        tilesDiv.innerHTML = "";
        return;
      }
      // Build details text
      detailsDiv.textContent = `${currentSet.year} ${currentSet.name} was released on ${currentSet.release_date}. Each box contains ${currentSet.configuration}.`;
      notesDiv.textContent = currentSet.notes || "No additional notes available.";
      
      // Build six tiles
      tilesDiv.innerHTML = ""; // clear previous content
      // Hero tiles: rookie percentage and total cards per case
      const heroTile1 = document.createElement('div');
      heroTile1.className = 'tile hero';
      heroTile1.textContent = "Rookie %: " + (currentSet.rookie_percentage || "N/A");
      tilesDiv.appendChild(heroTile1);
      
      const totalCardsPerCase = computeTotalCardsPerCase(currentSet);
      const heroTile2 = document.createElement('div');
      heroTile2.className = 'tile hero';
      heroTile2.textContent = "Total Cards/Case: " + (totalCardsPerCase || "N/A");
      tilesDiv.appendChild(heroTile2);
      
      // Supporting tiles: boxes per case, packs per box, cards per pack, cards per box
      const tileBoxes = document.createElement('div');
      tileBoxes.className = 'tile';
      tileBoxes.textContent = "Boxes/Case: " + (currentSet.boxes_per_case || "N/A");
      tilesDiv.appendChild(tileBoxes);
      
      const tilePacks = document.createElement('div');
      tilePacks.className = 'tile';
      tilePacks.textContent = "Packs/Box: " + (currentSet.packs_per_box || "N/A");
      tilesDiv.appendChild(tilePacks);
      
      const tileCardsPack = document.createElement('div');
      tileCardsPack.className = 'tile';
      tileCardsPack.textContent = "Cards/Pack: " + (currentSet.cards_per_pack || "N/A");
      tilesDiv.appendChild(tileCardsPack);
      
      const cardsPerBox = computeCardsPerBox(currentSet);
      const tileCardsBox = document.createElement('div');
      tileCardsBox.className = 'tile';
      tileCardsBox.textContent = "Cards/Box: " + (cardsPerBox || "N/A");
      tilesDiv.appendChild(tileCardsBox);
    }

    // Helper: compute total cards per case = boxes_per_case * packs_per_box * cards_per_pack (if numeric)
    function computeTotalCardsPerCase(setObj) {
      const boxes = parseFloat(setObj.boxes_per_case);
      const packs = parseFloat(setObj.packs_per_box);
      const cards = parseFloat(setObj.cards_per_pack);
      if (isNaN(boxes) || isNaN(packs) || isNaN(cards)) return null;
      return boxes * packs * cards;
    }

    // Helper: compute cards per box = packs_per_box * cards_per_pack
    function computeCardsPerBox(setObj) {
      const packs = parseFloat(setObj.packs_per_box);
      const cards = parseFloat(setObj.cards_per_pack);
      if (isNaN(packs) || isNaN(cards)) return null;
      return packs * cards;
    }

    // Update Key Rookies section using config.keyPlayers filtered by type "rookie" and selected year
    function updateKeyRookies() {
      const rookieContainer = document.getElementById('rookie-tiles');
      rookieContainer.innerHTML = "";
      const selectedYear = document.getElementById('setYearSelect').value;
      if (config.keyPlayers && Array.isArray(config.keyPlayers)) {
        // Filter key players for type 'rookie' and for the selected year
        const keyRookies = config.keyPlayers.filter(player => player.type === 'rookie' && player.year === selectedYear);
        if (keyRookies.length > 0) {
          keyRookies.forEach(player => {
            const tile = document.createElement('div');
            tile.className = 'tile';
            // Build tile content: player's name, images and notes.
            tile.innerHTML = `<strong>${player.name}</strong><br>
              <img src="${player.playerPic}" alt="${player.name}" style="width:50px;height:50px;"><br>
              <img src="${player.teamPic}" alt="Team" style="width:50px;height:50px;"><br>
              ${player.notes || ""}`;
            rookieContainer.appendChild(tile);
          });
        } else {
          rookieContainer.textContent = "No key rookie players found for the selected year.";
        }
      } else {
        rookieContainer.textContent = "No key players data available.";
      }
    }

    // Update Break Sniffer calculations
    function updateBreakSniffer() {
      if (!currentSet) {
        alert("Please select a valid set first.");
        return;
      }
      // Get inputs
      const costCase = parseFloat(document.getElementById('caseCost').value);
      const markupVal = parseFloat(document.getElementById('markupValue').value) || 0;
      const usePercent = document.getElementById('markupToggle').checked;
      const suppliesCost = parseFloat(document.getElementById('suppliesCost').value);
      const blendedTax = parseFloat(document.getElementById('blendedTax').value);
      
      // Compute cost of case including markup
      let costWithMarkup = 0;
      if (usePercent) {
        costWithMarkup = costCase * (1 + markupVal/100);
      } else {
        costWithMarkup = costCase + markupVal;
      }
      
      // Whatnots cut is 8% of costWithMarkup
      const whatnotsCut = costWithMarkup * 0.08;
      
      // For each team in currentSet.cards, compute:
      // distribution percentage = teamCards / totalCards
      // distributed cost = costCase * distribution percentage
      // transaction cost per team = distributed cost * (1 + blendedTax/100) * 0.029 + 0.30
      // cost of business per team = suppliesCost + transaction cost
      // Then (for the table) also compute:
      // - Avg. Cards per Case = distribution percentage * totalCardsPerCase
      // - Distributed Cost + Markup = if usePercent then distributedCost*(1+markupVal/100)
      //   else distributedCost + (markupVal * distribution percentage)
      
      const teams = currentSet.cards;
      const teamNames = Object.keys(teams);
      const totalCards = teamNames.reduce((sum, team) => sum + teams[team], 0);
      const totalCardsPerCase = computeTotalCardsPerCase(currentSet);
      
      // For overall cost of business, we sum over teams
      let totalCostOfBusiness = 0;
      
      // Prepare table body
      const tbody = document.getElementById('team-table').querySelector('tbody');
      tbody.innerHTML = "";
      
      teamNames.forEach(team => {
        const teamCards = teams[team];
        const distribution = teamCards / totalCards;
        const distributedCost = costCase * distribution;
        const transactionCost = distributedCost * (1 + blendedTax/100) * 0.029 + 0.30;
        const costBusinessTeam = suppliesCost + transactionCost;
        totalCostOfBusiness += costBusinessTeam;
        const avgCardsCase = totalCardsPerCase ? (distribution * totalCardsPerCase).toFixed(2) : "N/A";
        let distCostWithMarkup = 0;
        if (usePercent) {
          distCostWithMarkup = distributedCost * (1 + markupVal/100);
        } else {
          distCostWithMarkup = distributedCost + (markupVal * distribution);
        }
        
        // Create table row
        const row = document.createElement('tr');
        // For team logo, if available you might substitute an <img> tag; here we just show the team name.
        row.innerHTML = `
          <td>${team}</td>
          <td>${teamCards}</td>
          <td>${(distribution * 100).toFixed(2)}%</td>
          <td>${avgCardsCase}</td>
          <td>$${distCostWithMarkup.toFixed(2)}</td>
        `;
        tbody.appendChild(row);
      });
      
      // Overall Breaker's Profit = (markup amount) - whatnotsCut - totalCostOfBusiness
      const markupAmount = costWithMarkup - costCase;
      const breakersProfit = markupAmount - whatnotsCut - totalCostOfBusiness;
      
      // Update break tiles (three vertical tiles next to pie chart)
      const breakTiles = document.getElementById('break-tiles');
      breakTiles.innerHTML = "";
      const tileProfit = document.createElement('div');
      tileProfit.className = 'tile';
      tileProfit.textContent = "Breaker's Profit: $" + breakersProfit.toFixed(2);
      breakTiles.appendChild(tileProfit);
      
      const tileWhatnots = document.createElement('div');
      tileWhatnots.className = 'tile';
      tileWhatnots.textContent = "Whatnots Cut: $" + whatnotsCut.toFixed(2);
      breakTiles.appendChild(tileWhatnots);
      
      const tileBusiness = document.createElement('div');
      tileBusiness.className = 'tile';
      tileBusiness.textContent = "Cost of Business: $" + totalCostOfBusiness.toFixed(2);
      breakTiles.appendChild(tileBusiness);
      
      // Draw pie chart showing percentage breakdown of markupAmount allocated to:
      // - Breaker's Profit, Whatnots Cut, and Cost of Business.
      const data = [
        { label: "Profit", value: breakersProfit },
        { label: "Whatnots", value: whatnotsCut },
        { label: "Business", value: totalCostOfBusiness }
      ];
      drawPieChart(data, markupAmount);
    }

    // Draw a simple pie chart on canvas given data and total (for percentage calculation)
    function drawPieChart(data, total) {
      const canvas = document.getElementById('pieChart');
      const ctx = canvas.getContext('2d');
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = Math.min(centerX, centerY) - 10;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      let startAngle = 0;
      
      // Define a set of colors (or compute them)
      const colors = ["#4caf50", "#ff9800", "#2196f3"];
      
      data.forEach((d, i) => {
        const sliceAngle = (d.value / total) * 2 * Math.PI;
        ctx.fillStyle = colors[i % colors.length];
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, radius, startAngle, startAngle + sliceAngle);
        ctx.closePath();
        ctx.fill();
        startAngle += sliceAngle;
      });
      
      // Optionally add labels
      startAngle = 0;
      data.forEach((d, i) => {
        const sliceAngle = (d.value / total) * 2 * Math.PI;
        const midAngle = startAngle + sliceAngle/2;
        const labelX = centerX + (radius / 2) * Math.cos(midAngle);
        const labelY = centerY + (radius / 2) * Math.sin(midAngle);
        ctx.fillStyle = "#000";
        ctx.font = "12px Arial";
        ctx.fillText(d.label, labelX - 10, labelY);
        startAngle += sliceAngle;
      });
    }

    // Load config on startup
    loadConfig();
  </script>
</body>
</html>
